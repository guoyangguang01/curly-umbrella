# jdk1.7 数组加链表的结构

通过hash算法获取到对应的hash值，对该值进行hash取余获得数组的下标，再将该hash值存入到对应的数组下标中

链表，如果两个hash值相同时，会产生hash碰撞，解决方法有再散列法和链地址法，hashmap才用的是链地址法，当存储的时候，该数组下标已经有值，则会产生一个新的node对象，指向当前已存在的值，同时该节点对象从头部插入到链表中，并将数组改下表的值替换成最近的值。
 
数组的初始化长度不满足2的多次幂时，会将其修正为标准数组长度，向上取到最近的2的多次幂的值 
 
resize 扩容方法 当数组的已使用的空间达到了负载因子的限定的时候，会进行扩容，才用位运算扩大到当前数组标准长度的两倍

当每次添加节点，包括数组节点和链表节点时，size都会加1，删除节点时，size会减一，避免了对全表的遍历

负载因子 标准为0.75

modcount 防止产生多线程问题的解决方案，会触发fast fail，抛出并发修改异常

1.7扩容之后会对所有的值进行重新hash，性能不高

# jdk1.8 采用了数组加红黑树的数据结构

根据map的使用场景，读写操作都非常的常见，而链表是典型的写快于读的数据结构，如此一来，将会导致链表过长之后读操作的性能大幅降低，严重影响使用，所以jdk1.8在链表的长度大于8时会将链表转化为红黑树，提高查询效率

链表的插入方式改为了尾插时，因为新的数据结构每次添加链表节点时都会遍历链表查询是否长度过长，采用头插法将不再能节省遍历时间，同时尾插法也不需要对数组下标的值进行替换，节省了一步写的操作。